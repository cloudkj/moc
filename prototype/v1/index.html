<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mobile Game Controller - Directional Floor</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #2a2b2e; touch-action: none; }
        canvas { display: block; }

        /* Joystick */
        #zone_joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            z-index: 10;
        }

        /* Status UI */
        #status-text {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: bold;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            pointer-events: none;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        #loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: sans-serif;
            font-size: 1.5rem;
            color: white;
            pointer-events: none;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading-text">Loading Model...</div>
    <div id="status-text">State: Idle</div>
    <div id="zone_joystick"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const ANIM_NAMES = {
            idle: 'Idle',  
            walk: 'Walking',  
            run:  'Running'    
        };
        const RUN_THRESHOLD = 0.8; 
        const BACKGROUND_COLOR = 0x2a2b2e;
        const SPEED_WALK = 0.5; 
        const SPEED_RUN = 1.5;

        // --- VARIABLES ---
        let mixer, model;
        let actions = {};
        let activeAction;
        let currentState = 'idle'; 
        const clock = new THREE.Clock();

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(BACKGROUND_COLOR);
        scene.fog = new THREE.Fog(BACKGROUND_COLOR, 10, 50);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- FLOOR TEXTURE GENERATOR ---
        function getCheckerboardTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            context.fillStyle = '#404040'; 
            context.fillRect(0, 0, 512, 512);
            context.fillStyle = '#505050'; 
            context.fillRect(0, 0, 256, 256);
            context.fillRect(256, 256, 256, 256);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(20, 20); 
            tex.anisotropy = 16;
            
            // KEY FIX 1: Set rotation center to middle of texture
            tex.center.set(0.5, 0.5);
            
            return tex;
        }

        const floorTexture = getCheckerboardTexture();

        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ 
            map: floorTexture, 
            roughness: 0.8,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const gridHelper = new THREE.GridHelper(100, 50, 0x888888, 0x000000);
        gridHelper.position.y = 0.01; 
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // --- CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.enableDamping = true;
        controls.minDistance = 2;
        controls.maxDistance = 15;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- JOYSTICK ---
        const joystickManager = nipplejs.create({
            zone: document.getElementById('zone_joystick'),
            mode: 'static',
            position: { left: '50%', top: '50%' },
            color: 'white'
        });

        joystickManager.on('move', function (evt, data) {
            if (!model) return;
            const angle = data.angle.radian;
            const targetRotation = angle - Math.PI / 2; 
            
            let diff = targetRotation - model.rotation.y;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            model.rotation.y += diff * 0.1; 

            const force = Math.min(data.force, 1.5);
            if (force > RUN_THRESHOLD) switchAction('run');
            else switchAction('walk');
        });

        joystickManager.on('end', () => switchAction('idle'));

        // --- LOADER ---
        const loader = new GLTFLoader();
        loader.load('StarbotAnimated.glb', function (gltf) { 
            model = gltf.scene;
            scene.add(model);
            
            model.traverse(o => { if (o.isMesh) o.castShadow = true; });

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            model.position.x += (model.position.x - center.x);
            model.position.y += (model.position.y - center.y); 
            model.position.z += (model.position.z - center.z);

            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach(clip => { actions[clip.name] = mixer.clipAction(clip); });

            const idleClip = actions[ANIM_NAMES.idle] || actions[gltf.animations[0]?.name];
            const walkClip = actions[ANIM_NAMES.walk] || actions[gltf.animations[1]?.name];
            const runClip  = actions[ANIM_NAMES.run]  || actions[gltf.animations[2]?.name];

            actions['idle'] = idleClip;
            actions['walk'] = walkClip;
            actions['run']  = runClip;

            activeAction = actions['idle'];
            if(activeAction) activeAction.play();

            document.getElementById('loading-text').style.display = 'none';

        }, undefined, e => console.error(e));

        function switchAction(newState) {
            if (currentState === newState) return;
            const newAction = actions[newState];
            const oldAction = activeAction;
            if (!newAction) return;

            document.getElementById('status-text').innerText = newState;
            
            newAction.reset();
            newAction.play();
            if (oldAction) newAction.crossFadeFrom(oldAction, 0.2, true);

            activeAction = newAction;
            currentState = newState;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (mixer) mixer.update(delta);
            controls.update();
            renderer.render(scene, camera);

            // --- KEY FIX 2: Dynamic Floor Rotation ---
            if (model) {
                // 1. Sync Texture Rotation to Character Rotation
                // If character turns, the floor texture turns with them.
                floorTexture.rotation = model.rotation.y;
                
                // 2. Sync Grid Helper Rotation 
                // This keeps the wireframe grid aligned with the checkerboard
                gridHelper.rotation.y = model.rotation.y;

                // 3. Scroll Logic
                let currentScrollSpeed = 0;
                if (currentState === 'walk') currentScrollSpeed = SPEED_WALK;
                else if (currentState === 'run') currentScrollSpeed = SPEED_RUN;
                
                // Because we rotated the texture to match the player, 
                // we ONLY need to scroll along the Y axis.
                floorTexture.offset.y -= currentScrollSpeed * delta;
            }
        }

        animate();
    </script>
</body>
</html>